{-# LANGUAGE LambdaCase #-}

module AOC.Day12 (day12) where

import Data.List (foldl')
import Data.Monoid (Sum (..))
import Safe (readMay)

import AOC.Types

day12 :: Solution [Action] Int Int
day12 =
    Solution
        { parse = traverse parseAction . lines
        , part1 = Just . getSum . distance . foldl' action newShip
        , part2 = const Nothing
        }

data Action = N (Sum Int) | S (Sum Int) | E (Sum Int) | W (Sum Int) | L (Sum Int) | R (Sum Int) | F (Sum Int)
    deriving (Show)

parseAction :: String -> Maybe Action
parseAction "" = Nothing
parseAction (x : xs) = action <*> (Sum <$> readMay xs)
  where
    action = case x of
        'N' -> Just N
        'S' -> Just S
        'E' -> Just E
        'W' -> Just W
        'L' -> Just $ L . turns
        'R' -> Just $ R . turns
        'F' -> Just F
        _ -> Nothing
    turns = Sum . (`div` 90) . getSum

data Direction = North | East | South | West
    deriving (Show, Eq, Ord, Enum, Bounded)

data Ship = Ship Direction (Sum Int) (Sum Int)
    deriving (Show)

newShip :: Ship
newShip = Ship East 0 0

distance :: Ship -> Sum Int
distance (Ship _ x y) = abs x + abs y

action :: Ship -> Action -> Ship
action ship@(Ship dir x y) = \case
    N n -> Ship dir x (y <> n)
    S n -> Ship dir x (y <> (- n))
    E n -> Ship dir (x <> n) y
    W n -> Ship dir (x <> (- n)) y
    L n -> Ship (turn (- n) dir) x y
    R n -> Ship (turn n dir) x y
    F n -> action ship (forwardAction n)
  where
    turn n = toEnum . (`mod` dirCount) . (getSum n +) . fromEnum
    dirCount = succ $ fromEnum (maxBound :: Direction)
    forwardAction = case dir of
        North -> N
        East -> E
        South -> S
        West -> W
